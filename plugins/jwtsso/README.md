# JSON Web Token (JWT) SSO integration with Vanilla

## JWT Overview

JSON Web Token (JWT) is a JSON-based open standard [(RFC 7519)]('https://tools.ietf.org/html/rfc7519') for creating access tokens that assert some number of claims. For example, a server could generate a token that has the claim that the bearer of the token has been authenticated. The tokens are signed by the server with a shared key so the client is able to verify that the token is legitimate. 

JWTs are designed to be compact, URL-safe and usable especially in web browser single sign-on (SSO) context. There are a number of registered claims that can be passed in the payload such as:

 - 'iss' (issuer)
 - 'sub' (subject)
 - 'aud' (intended audience)
 - 'exp' (expire time)
 - 'iat' (issued at time)
 - 'nbf' (not before time)

 
as well as private claims, which can be anything that an issuer and a client agree upon, e.g. 'email' or 'role'.

## Features overview

The JWT SSO plugin allows the client configure an authorization provider in their dashboard to store:

 - a shared secret (either input an existing hash or create one to be shared with the authenticating server)
 - a hashing algorithm for signing the token
 - URLs for users to be directed to for signing in, or registering on the authenticating server
 - names of keys to translate data being passed in the payload of the token

Also on the settings page of the dashboard is an expamle of a signed token that the user can use for debugging purposes.

## Workflow

When a visitor to a forum clicks to log into the forum he/she is sent to the log in form of the Authentication Provider, with a "target" variable. The "target" variable is the URL of the page from which they originated the request, the URL they are to be returned to when logged in. 

Once the Authentication provider determines that the user is legitimate, he/she is redirected to [forum addresss]/entry/connect/JWTSSO?Target=[the passed target] with an HTTP Authorization header set to `Bearer: [signed JSON Web Token]` .

`/entry/connect/JWTSSO` determines if there is a valid Bearer token and then checks that :

 - the time is valid (after the 'iat' and/or 'nbf', and before 'exp')
 - the 'aud' is the one recorded in the provider (usually the forum URL)
 - the 'iss' is the one recorder in the provider (usually the issuer's base domain name)
 - the token is signed using the chosen hashing algorithm and secret
 

## Token Creation

A JWT consists of three parts, the header, the payload and the signature.

### The Header

In the header we are expecting a JSON array with two key/value pairs: 

 - `typ` hardcoded to `JWT`
 - `alg` one of three valid hmac hashing algorithms (`HS256`, `HS512`, `HS384`) chosen by the client

### The Payload

In the payload we require: 

 - `iss` the issuer (usually the domain of the Authentication Provider)
 - `sub` a unique identifier passed that will always accompany the user when he/she logs in
 - `aud` the intended audience (usually the URL of the forum)
 - `email` the email address of the user to either create an account or connect to an existing user
 - `exp` the expiry time of the token (unix time stamp)
 - either `iat` or `nbf` unix time stamp when the token was created. We will reject any token that doesn't have one or has one set in the future.
 

The payload can optionally include:
 
 - `displayname` as a username to be displayed on the site. If one is not present the user will be asked to create one on the first log in.
 

### The Signature
The signature is generated by the Authentication Provider using the following steps.

#### 1. Encode the Header:

 - ensure that it is a valid JSON string
 - strip any slashes
 - base64_encode it
 - substitute any '+/' with '-_' in the resulting string
 - remove an '=' in the resulting string
  
In PHP this would be done as follows: 

`$encodedHeader = str_replace('=', '', strtr(base64_encode(stripslashes($rawJSONString)), '+/', '-_'));`
  
#### 2. Encode the Payload:

 - ensure that it is a valid JSON string
 - strip any slashes
 - base64_encode it
 - substitute any '+/' with '-_' in the resulting string
 - remove an '=' in the resulting string

In PHP this would be done as follows: 

`$encodedPayload = str_replace('=', '', strtr(base64_encode(stripslashes($rawJSONString)), '+/', '-_'));`
  
#### 3. Concatenate the encoded Header and Payload:
Concatenate the encoded header and payload with a `.` (xxxxx.yyyyyyyyyyy)

#### 4. Prepare the Secret
 
 - substitue any '-_' with '+/'
 - base64_decode it

In PHP: 

`$preparedSecret = base64_decode(strtr($secret, '-_', '+/'));`

#### 5. Sign the Header and the Payload:

 - hash_hmac using the chosen algorithm
 - strip any slashes
 - base64_encode it
 - substitute any '+/' with '-_' in the resulting string
 - remove an '=' in the resulting string
 
In PHP: 

`$signedString = trim($this->base64url_encode(hash_hmac($algorithm, $concatenatedHeaderAndPayload, $preparedSecret, true)));`

#### 6. Build the Token

 - Concatenate the signature string to the end of the encoded header.payload with `.` in between (xxxxxx.yyyyyyyyyy.zzzzzzzzzz)
 - trim the result.
 

## Troubleshooting

When the DbLogger plugin is turned on there are descriptive messages being saved whenever there is an error reading a JWT. A copy of the user payload is saved on successful logins.

On the settings page of the dashboard a sample JWT is generated when the miniumum requirements of the set up are done. It embeds by default the logged-in user's email (prepended with '+++') as the `email` in the token and a fake id (1234) as the `sub`. Users who have access to the config file can change these values:
 
 - JWTSSO.TestToken.ForeignKey (`sub`)
 - JWTSSO.TestToken.Email (`email`)
 - JWTSSO.TestToken.Name (`displayname`)
 - JWTSSO.TestToken.ExpiryTime (`exp`)
 
 To test the validity of the secret and to see the payload, go to [JWT.io]('https://jwt.io'). To test the token, use a browser plugin to set the HTTP request headers to Authorization Bearer: [the token] and navigate to the forum address `/entry/connect/JWTSSO`
 
 One other problem that can arise in the production environment is if the time on the server that is righting the token is skewed in relation to the server that is reading the token. There is a built in leeway of 5 minutes +/- for such an occassion. This value can be adjusted in the config by changing the value of `JWTSSO.leewaytime`.
